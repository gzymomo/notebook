# 软件测试报告

# **1.**引言

## 1.1 目的

​	建立起一套软件测试规范文档，通过该规范文档，能够为公司提供一个相关方面的测试标准，包含测试内容有性能测试，基准测试，安全测试，渗透测试等相关内容。并利用相关工具能够实现对必要项目实施完整的测试流程，提供一个标准的测试文档。目前该方面处于摸索当作，自己对测试相关行业的储备不是特别深，在不断学习的道路上不断完善该测试报告，最终得以实践。



## 1.2 测试范围和内容

### 1.2.1 基准测试

基准测试：

- sysbench进行cpu性能基准测试。

- sysbench进行文件i/o性能基准测试。

- sysbench进行内存速度基准测试。

- sysbench进行线程子系统性能测试。

- sysbench进行mysql性能基准测试。

### 1.2.2 性能测试

性能压测：

- jmeter进行数据库性能压测。

- jmeter进行http接口压测。

### 1.2.3 安全测试



### 1.2.4 渗透测试



# 2.基准测试

以下分别描述测试过程中主要的各项活动，介绍测试过程内容，遇到的问题，以及其它发生的主要事件。**下面的数据统计最好以表格，或条形图、饼状图的形式展现**

## 2.1. 测试过程

### 2.1.1服务器配置信息查看

编写bash脚本，查看服务器基础配置信息。

```bash
vi showServerConfig.sh
# 赋予脚本执行权限
chmod +x showServerConfig.sh
```



具体脚本内容如下：

```bash
#!/bin/bash
echo ======= cpu个数： =======
grep 'physical id' /proc/cpuinfo | sort -u | wc -l
echo ======= cpu核数： =======
cat /proc/cpuinfo | grep "cpu cores" | uniq
echo ======= cpu型号： =======
cat /proc/cpuinfo | grep 'model name' |uniq
echo ======= cpu内核频率： =======
cat /proc/cpuinfo |grep MHz|uniq
echo ======= cpu统计信息： =======
lscpu
echo ======= 内存总数： =======
cat /proc/meminfo | grep MemTotal
echo ======= 内核版本： =======
cat /proc/version
echo ======= 操作系统内核信息： =======
uname -a
echo ======= 磁盘信息： =======
fdisk -l
```

 

### 2.1.2通过sysbench进行基准测试

- sysbench进行cpu性能基准测试。
- sysbench进行文件i/o性能基准测试。
- sysbench进行内存速度基准测试。
- sysbench进行线程子系统性能测试。
- sysbench进行mysql性能基准测试。



 sysbench进行压力测试过程：

1.  prepare阶段，这个阶段是用来做准备的，对所需测试的表，添加测试数据。
2.  run 阶段进行数据库压力测试。
3.  cleanup 阶段去清除测试数据，也就是将prepare阶段的数据进行清除。

 

#### 数据库基准测试

##### 数据库测试参数说明

```bash
General database options:

  --db-driver=STRING  specifies database driver to use ('help' to get list of available drivers) [mysql] #指定数据库驱动，默认是mysql
  --db-ps-mode=STRING prepared statements usage mode {auto, disable} [auto]                              #
  --db-debug[=on|off] print database-specific debug information [off]                                    #dubug模式


Compiled-in database drivers:
  mysql - MySQL driver

mysql options:
  --mysql-host=[LIST,...]          MySQL server host [localhost]
  --mysql-port=[LIST,...]          MySQL server port [3306]
  --mysql-socket=[LIST,...]        MySQL socket
  --mysql-user=STRING              MySQL user [sbtest]
  --mysql-password=STRING          MySQL password []
  --mysql-db=STRING                MySQL database name [sbtest]              #数据库名字，默认是sbtest
  --mysql-ssl[=on|off]             use SSL connections, if available in the client library [off]  #以下是ssl的连接测试
  --mysql-ssl-key=STRING           path name of the client private key file
  --mysql-ssl-ca=STRING            path name of the CA file
  --mysql-ssl-cert=STRING          path name of the client public key certificate file
  --mysql-ssl-cipher=STRING        use specific cipher for SSL connections []
  --mysql-compression[=on|off]     use compression, if available in the client library [off]      #压缩测试
  --mysql-debug[=on|off]           trace all client library calls [off]
  --mysql-ignore-errors=[LIST,...] list of errors to ignore, or "all" [1213,1020,1205]            #忽略的错误
  --mysql-dry-run[=on|off]         Dry run, pretend that all MySQL client API calls are successful without executing them [off]
```

##### 数据库测试实践

- prepare

首先创建一个数据库：`create database sbtest; `，然后开始准备数据：

```bash
sysbench /data/sysbench-master/src/lua/oltp_read_write.lua --tables=3 --table_size=10000000 --mysql-user=root --mysql-password=123456 --mysql-host=10.0.102.214 --mysql-port=3306 --mysql-db=sbtest prepare
```

- run

```bash
sysbench /data/sysbench-master/src/lua/oltp_point_select.lua --tables=3 --table_size=10000000 --mysql-user=root --mysql-password=123456 --mysql-host=10.0.102.214 --mysql-port=3306 --mysql-db=sbtest --threads=128 --time=100 --report-interval=5 run
```

- 测试结果分析

```bash
SQL statistics:
    queries performed:
        read:                            2638920   #总的select数量
        write:                           0
        other:                           0
        total:                           2638920
    transactions:                        2638920 (26382.71 per sec.)   #TPS
    queries:                             2638920 (26382.71 per sec.)   #QPS
    ignored errors:                      0      (0.00 per sec.)        #忽略的错误
    reconnects:                          0      (0.00 per sec.)        #重新连接

Throughput:
    events/s (eps):                      26382.7081                   #每秒的事件数，一般和TPS一样
    time elapsed:                        100.0246s                    #测试的总时间
    total number of events:              2638920                      #总的事件数，一般和TPS一样

Latency (ms):
         min:                                    0.11          #最小响应时间
         avg:                                    4.85          #平均响应时间
         max:                                  649.29          #最大响应时间
         95th percentile:                       25.74          #95%的响应时间是这个数据  
         sum:                             12796148.28

Threads fairness:
    events (avg/stddev):           20616.5625/196.08
    execution time (avg/stddev):   99.9699/0.00#在这个测试中，可以看到TPS与QPS的大小基本一致，说明这个lua脚本中的一个查询一般就是一个事务！
```

一般关注的指标主要有:

- - response time avg：平均响应时间（后面的95%的大小可以通过–percentile=98的方式去更改）。
- - transactions：精确的说是这一项后面的TPS，但如果使用了–skip-trx=on，这项事务数为0，需要用total number of events去除以总时间，得到tps（其实还可以分为读tps和写tps）。
- - queries：用它除以总时间，得到吞吐量QPS。

刚开始的时候有一个明显的上升，这时候是因为在bp中没有缓存数据，需要从磁盘中读数据，也就是预热阶段！

- cleanup

```bash
sysbench /data/sysbench-master/src/lua/oltp_read_write.lua --tables=3 --table_size=10000000 --mysql-user=root --mysql-password=123456 --mysql-host=10.0.102.214 --mysql-port=3306 --mysql-db=sbtest cleanup
```





####  I/O基准测试

##### I/O测试参数说明

```bash
[root@test3 ~]# sysbench fileio help               #查看IO测试的文档
sysbench 1.1.0 (using bundled LuaJIT 2.1.0-beta3)

fileio options:
  --file-num=N                  number of files to create [128]              #文件的数量
  --file-block-size=N           block size to use in all IO operations [16384] #文件块的大小，如果要是针对INNODB的测试，可以设置为innodb_page_size的大小
  --file-total-size=SIZE        total size of files to create [2G]             #文件的总大小
  --file-test-mode=STRING       test mode {seqwr【顺序写】, seqrewr【顺序读写】, seqrd【顺序读】, rndrd【随机读】, rndwr【随机写】, rndrw【随机读写】} #文件测试模式
  --file-io-mode=STRING         file operations mode {sync【同步】,async【异步】,mmap【map映射】} [默认为：sync]          #文件的io模式
  --file-async-backlog=N        number of asynchronous operatons to queue per thread [128] #打开文件时的选项，这是与API相关的参数。
  --file-extra-flags=[LIST,...] #打开文件时的选项，这是与API相关的参数。可选有sync，dsync，direct。--file-fsync-freq=N           #执行fsync函数的频率，fsync主要是同步磁盘文件，因为可能有系统和磁盘缓冲的关系。默认为100，如果为0表示不使用fsync。
  --file-fsync-all[=on|off]     #每执行完一次写操作，就执行一次fsync，默认未off。--file-fsync-end[=on|off]     #在测试结束时，执行fsync，默认为on。--file-fsync-mode=STRING      #文件同步函数的选择，同样是和API相关的参数，由于多个操作对fdatasync支持的不同，因此不建议使用fdatasync。默认为fsync。--file-merged-requests=N      #尽可能合并此数量的io请求(0-不合并)，默认为[0]。
  --file-rw-ratio=N             #测试时的读写比例，默认是2:1。
```

##### I/O测试实践

- prepare

```bash
sysbench fileio --file-num=10 --file-total-size=50G prepare
```

- run(这里进行随机读写测试)

```bash
sysbench fileio --file-num=10 --file-total-size=50G --file-block-size=16384 --file-test-mode=rndrw --file-io-mode=sync --file-extra-flags=direct --time=100  --threads=16 --report-interval=10 run
```

- - 顺序读的测试

  ```bash
  sysbench fileio --file-num=10 --file-total-size=50G --file-block-size=16384 --file-test-mode=seqrd --file-io-mode=sync --file-extra-flags=direct --time=100  --threads=16 --report-interval=10 run
  ```

- cleanup

```bash
sysbench fileio --file-num=10 --file-total-size=50 cleanup
```

#### 磁盘I/O测试

- prepare 

```bash
sysbench --test=fileio --file-num=16 --file-total-size=2G prepare
```

参数含义：
–test=fileio 测试的名称叫做 fileio
–file-num=16 文件的数量是 16 个
–file-total-size=2G 文件的总体大小是 2GB



- 测试多线程下小IO的随机只读性能

```bash
sysbench --test=fileio --file-num=16 --file-total-size=2G --file-test-mode=rndrd  --file-extra-flags=direct --file-fsync-freq=0 --file-block-size=16384 run
```

参数含义：
–test=fileio 测试的名称叫做 fileio
–file-num=16 文件的数量是 16 个
–file-total-size=2G 文件的总体大小是 2GB
–file-test-mode=rndrd 测试模式是随机读取
–file-extra-flags=direct 使用额外的标志来打开文件{sync,dsync,direct}
–file-fsync-freq=0 执行 fsync() 的频率
–file-block-size=16384 测试时文件块的大小位 16384 (16K)



结果分析：

```bash
Throughput:
    read, MiB/s:                  23.24
    written, MiB/s:               0.00
General statistics:
    total time:                          10.0002s
    total number of events:              14877
 
Latency (ms):
         min:                                  0.15
         avg:                                  0.67
         max:                                168.34
         95th percentile:                      0.84
         sum:                               9978.66
 
Threads fairness:
    events (avg/stddev):           14877.0000/0.00
    execution time (avg/stddev):   9.9787/0.00
```

随机读取的数据吞吐量：23.24 MB/s
随机读的IOPS： 1487.34
平均延迟：0.67毫秒



- 测试多线程下小IO的随机写入性能

```bash
sysbench --test=fileio --file-num=16 --file-total-size=2G --file-test-mode=rndwr --max-time=180  --file-extra-flags=direct --file-fsync-freq=0 --file-block-size=16384 run
```

参数含义：
–file-test-mode=rndwr 测试模式是随机写

- 测试多线程下小IO的随机读写性能

```bash
sysbench --test=fileio --file-num=16 --file-total-size=2G --file-test-mode=rndrw --file-extra-flags=direct --file-fsync-freq=0 --file-block-size=16384 run
```

参数含义：
–file-test-mode=rndrw  测试模式是随机读写



#### File I/O测试

##### File I/O测试参数说明

```bash
#/usr/local/sysbench_1/bin/sysbench fileio help
sysbench 1.0.9 (using bundled LuaJIT 2.1.0-beta2)
 
fileio options:
  --file-num=N              number of files to create [128]
  --file-block-size=N       block size to use in all IO operations [16384]
  --file-total-size=SIZE    total size of files to create [2G]
  --file-test-mode=STRING   test mode {seqwr, seqrewr, seqrd, rndrd, rndwr, rndrw}
  --file-io-mode=STRING     file operations mode {sync,async,mmap} [sync]
  --file-async-backlog=N    number of asynchronous operatons to queue per thread [128]
  --file-extra-flags=STRING additional flags to use on opening files {sync,dsync,direct} []
  --file-fsync-freq=N       do fsync() after this number of requests (0 - don't use fsync()) [100]
  --file-fsync-all[=on|off] do fsync() after each write operation [off]
  --file-fsync-end[=on|off] do fsync() at the end of test [on]
  --file-fsync-mode=STRING  which method to use for synchronization {fsync, fdatasync} [fsync]
  --file-merged-requests=N  merge at most this number of IO requests if possible (0 - don't merge) [0]
  --file-rw-ratio=N         reads/writes ratio for combined test [1.5]
```

##### File I/O测试实践

- prepare（一定要到你测试的磁盘目录下执行，否则可能测试系统盘了）

```bash
sysbench fileio --file-total-size=15G --file-test-mode=rndrw --time=300 --max-requests=0 prepare
```

- run

```bash
sysbench fileio --file-total-size=15G --file-test-mode=rndrw --time=300 --max-requests=0 run
```

- cleanup

```bash
sysbench fileio --file-total-size=15G --file-test-mode=rndrw --time=300 --max-requests=0 cleanup
```





## 2.2. 测试结果总结

请用数据对测试进行总结，如测试用例的数量，通过率等，可按子系统来进行分类说明。

| ***\*测试轮次\**** | ***\*用例数\**** | ***\*用例通过率\**** | ***\*问题数\**** | ***\*备注\**** |
| ------------------ | ---------------- | -------------------- | ---------------- | -------------- |
| 第一轮             | 36               | 88.9%                | 16               |                |
| 第二轮             | 38               | 94.7%                | 6                |                |
| 第三轮             | 39               | 100%                 | 0                |                |
|                    |                  |                      |                  |                |

 

 

 

## 2.3. 缺陷分布总结

形成缺陷的模块分布、严重性分布、紧急程度分布等各项缺陷分布关系图





# 3.性能测试

以下分别描述测试过程中主要的各项活动，介绍测试过程内容，遇到的问题，以及其它发生的主要事件。**下面的数据统计最好以表格，或条形图、饼状图的形式展现**

## 2.1. 测试过程

### 2.1.1通过jmeter进行性能压测

jmeter进行数据库性能压测。

jmeter进行http接口压测。

 

 

## 2.2. 测试结果总结

请用数据对测试进行总结，如测试用例的数量，通过率等，可按子系统来进行分类说明。

| ***\*测试轮次\**** | ***\*用例数\**** | ***\*用例通过率\**** | ***\*问题数\**** | ***\*备注\**** |
| ------------------ | ---------------- | -------------------- | ---------------- | -------------- |
| 第一轮             | 36               | 88.9%                | 16               |                |
| 第二轮             | 38               | 94.7%                | 6                |                |
| 第三轮             | 39               | 100%                 | 0                |                |
|                    |                  |                      |                  |                |

 

 

 

## 2.3. 缺陷分布总结

形成缺陷的模块分布、严重性分布、紧急程度分布等各项缺陷分布关系图



# 4.安全测试

以下分别描述测试过程中主要的各项活动，介绍测试过程内容，遇到的问题，以及其它发生的主要事件。**下面的数据统计最好以表格，或条形图、饼状图的形式展现**

## 2.1. 测试过程



 

## 2.2. 测试结果



 

## 2.3. 缺陷分布

形成缺陷的模块分布、严重性分布、紧急程度分布等各项缺陷分布关系图



# 5.渗透测试

以下分别描述测试过程中主要的各项活动，介绍测试过程内容，遇到的问题，以及其它发生的主要事件。**下面的数据统计最好以表格，或条形图、饼状图的形式展现**

## 2.1. 测试过程总结



 

## 2.2. 测试结果总结

 

 

## 2.3. 缺陷分布总结

形成缺陷的模块分布、严重性分布、紧急程度分布等各项缺陷分布关系图



# 6.测试偏差

描述测试中发现的、没有满足需求或其它方面要求的部分，并给出详细的解释及建议的解决方案。

 

# **7.** 其他说明

描述没有在以上各部分涵盖的并且需要说明的内容，如计划和测试用例中的所有变更，以及每个变更的原因等。

 

# **8.**综合评价

针对本项目的测试说明各个部分的测试结果，并给出评价。

​	提供测试的全面评价，包括它的局限性，是否建议通过等。

本评价必须建立在测试结果和通过/不通过标准的基础上，并且对其评价结果的可靠性进行估计，如建议通过测试时，还可能存在哪些风险。

# 附：

