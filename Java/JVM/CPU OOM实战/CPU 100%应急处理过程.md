[TOC]

SSH登录服务器，使用 top 命令查看，几个Java进程CPU占用达到180%，190%，这几个Java进程对应同一个业务服务的几个Pod（或容器）。

# 定位
1. 使用 docker stats 命令查看本节点容器资源使用情况，对占用CPU很高的容器使用 docker exec -it <容器ID>bash 进入。
2. 在容器内部执行 top 命令查看，定位到占用CPU高的进程ID，使用 top -Hp <进程ID> 定位到占用CPU高的线程ID。
3. 使用 jstack <进程ID> > jstack.txt 将进程的线程栈打印输出。
4. 退出容器， 使用 docker cp <容器ID>:/usr/local/tomcat/jstack.txt ./ 命令将jstack文件复制到宿主机，便于查看。获取到jstack信息后，赶紧重启服务让服务恢复可用。
5. 将2中占用CPU高的线程ID使用 pringf '%x\n' <线程ID> 命令将线程ID转换为十六进制形式。假设线程ID为133，则得到十六进制85。在jstack.txt文件中定位到 nid=0x85的位置，该位置即为占用CPU高线程的执行栈信息。如下图所示，

![](https://img2020.cnblogs.com/other/1973721/202007/1973721-20200714195454292-684920069.png)

6. 与同事确认，该处为使用一个框架的excel导出功能，并且，导出excel时没有分页，没有限制！！！查看SQL查询记录，该导出功能一次导出50w条数据，并且每条数据都需要做转换计算，更为糟糕的是，操作者因为导出时久久没有响应，于是连续点击，几分钟内发起了10多次的导出请求。

使用命令 jstat -gcutil <进程ID> 2000 10 查看GC情况，如图
![](https://img2020.cnblogs.com/other/1973721/202007/1973721-20200714195454530-1484628390.png)

发现Full GC次数达到1000多次，且还在不断增长，同时Eden区，Old区已经被占满（也可使用jmap -heap <进程ID>查看堆内存各区的占用情况），使用jmap将内存使用情况dump出来，

jmap -dump:format=b,file=./jmap.dump 13
退出容器，使用 docker cp <容器ID>:/usr/local/tomcat/jmap.dump ./ 将dump文件复制到宿主机目录，下载到本地，使用 MemoryAnalyzer（下载地址：www.eclipse.org/mat/downloa… ）打开，如图

![](https://img2020.cnblogs.com/other/1973721/202007/1973721-20200714195454753-154177639.png)

如果dump文件比较大，需要增大MemoryAnalyzer.ini配置文件中的-Xmx值

发现占用内存最多的是char[], String对象，通过右键可以查看引用对象，但点开貌似也看不出所以然来，进入内存泄露报告页面，如图
![](https://img2020.cnblogs.com/other/1973721/202007/1973721-20200714195455003-1836739024.png)

该页面统计了堆内存的占用情况，并且给出疑似泄露点，在上图中点开“see stacktrace”链接，进入线程栈页面，

![](https://img2020.cnblogs.com/other/1973721/202007/1973721-20200714195456240-1859706214.png)